"""
VulnerabilitySearchTool - NVD CVE vulnerability search tool.
"""
import os
import json
import requests
import traceback
from typing import Dict, Any, Optional, List
from agent.basetool import ExecutableTool


class VulnerabilitySearchTool(ExecutableTool):
    name: str = "cve_search_nvd"
    description: str = "Search for CVE vulnerability information related to software keywords using the NVD API 2.0. Results include CVE ID, description, and CVSSv3 score, sorted in descending order by score."
    parameters: Dict[str, Any] = {
        "type": "object",
        "properties": {
            "keyword_search": {
                "type": "string",
                "description": "Software name or keyword to search for in NVD (e.g., 'BusyBox 1.33.1', 'OpenSSL', 'Linux Kernel'). Include the version number in the keyword if you need to match a specific version via NVD's keyword search."
            },
             "max_results": {
                  "type": "integer",
                  "description": "Limit the number of matching CVEs to return (the highest scored will be shown).",
                  "default": 10,
                  "minimum": 1,
                  "maximum": 50
             }
        },
        "required": ["keyword_search"]
    }
    timeout = 30

    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    REQUEST_TIMEOUT = 30
    DEFAULT_USER_AGENT = "AgentNvdSearchTool/1.2"

    def execute(self, keyword_search: str, max_results: int = 10, **kwargs) -> str:
        max_results = min(max_results, self.parameters["properties"]["max_results"]["maximum"])
        results_to_fetch = max(max_results * 2, 50)

        params = {
            "keywordSearch": keyword_search,
            "resultsPerPage": results_to_fetch,
            "startIndex": 0,
            "keywordExactMatch": None
        }

        print(f"Querying NVD API: keyword='{keyword_search}', fetching up to {results_to_fetch} potential results.")
        
        headers = {'User-Agent': self.DEFAULT_USER_AGENT}
        api_key = os.getenv("NVD_API_KEY")
        if api_key:
            headers['apiKey'] = api_key
            print("  (Found and using NVD_API_KEY)")

        try:
            response = requests.get(self.NVD_API_URL, params=params, timeout=self.REQUEST_TIMEOUT, headers=headers)
            response.raise_for_status()
            data = response.json()

            total_results = data.get("totalResults", 0)
            if total_results == 0:
                return f"NVD API found no CVEs related to the keyword '{keyword_search}'."

            vulnerabilities = data.get("vulnerabilities", [])
            if not vulnerabilities:
                 return f"NVD API reported {total_results} results for '{keyword_search}', but failed to retrieve vulnerability list details."

            print(f"NVD API returned {len(vulnerabilities)} raw results (total available: {total_results}). Processing and sorting...")

            filtered_cves = []
            for item in vulnerabilities:
                cve_item = item.get("cve", {})
                cve_id = cve_item.get("id")
                if not cve_id: continue

                cvss_v3_score = self._get_cvss_v3_score(cve_item.get("metrics", {}))

                description = self._get_english_description(cve_item.get("descriptions", []))

                filtered_cves.append({
                    "id": cve_id,
                    "score_v3": cvss_v3_score,
                    "description": description.strip()
                })

            if not filtered_cves:
                 return f"Found {total_results} potential CVEs related to '{keyword_search}', but could not extract valid CVE information after processing."

            filtered_cves.sort(key=lambda x: (x['score_v3'] is not None, x['score_v3'] if x['score_v3'] is not None else -1.0), reverse=True)

            if len(filtered_cves) > max_results:
                print(f"Displaying top {max_results} of {len(filtered_cves)} processed CVEs, sorted by score.")
                filtered_cves = filtered_cves[:max_results]
            
            output_text = (f"Top {len(filtered_cves)} CVE results for '{keyword_search}' (sorted by CVSSv3 score):\n\n")

            for idx, cve in enumerate(filtered_cves, 1):
                 output_text += f"{idx}. [{cve['id']}] (CVSSv3 Score: {cve['score_v3'] or 'N/A'})\n   {cve['description']}\n\n"

            return self._limit_output(output_text.strip())

        except requests.exceptions.Timeout:
            return f"[Error] NVD API request timed out ({self.REQUEST_TIMEOUT} seconds)."
        except requests.exceptions.HTTPError as e:
             return f"[Error] NVD API request failed: {e.response.status_code} {e.response.reason}. Please check API status or your query."
        except requests.exceptions.RequestException as e:
            return f"[Error] NVD API network request failed: {e}"
        except json.JSONDecodeError:
             return "[Error] NVD API returned invalid JSON data. The API might be temporarily unavailable or its format may have changed."
        except Exception as e:
            traceback.print_exc()
            return f"[Error] An internal error occurred while processing NVD API results: {e}"

    def _get_english_description(self, descriptions: List[Dict[str, str]]) -> str:
        for desc_item in descriptions:
            if desc_item.get("lang") == "en":
                return desc_item.get("value", "No English description available.")
        return "No description found."

    def _get_cvss_v3_score(self, metrics: Dict[str, Any]) -> Optional[float]:
        if "cvssMetricV31" in metrics and metrics["cvssMetricV31"]:
            try: return metrics["cvssMetricV31"][0]["cvssData"]["baseScore"]
            except (KeyError, IndexError, TypeError): pass
        if "cvssMetricV30" in metrics and metrics["cvssMetricV30"]:
            try: return metrics["cvssMetricV30"][0]["cvssData"]["baseScore"]
            except (KeyError, IndexError, TypeError): pass
        return None

    def _limit_output(self, text: str, max_len: int = 10000) -> str:
        if len(text) > max_len:
             last_newline = text.rfind('\n', 0, max_len)
             if last_newline != -1:
                  return text[:last_newline] + "\n...[Output truncated]"
             else:
                  return text[:max_len] + "...[Output truncated]"
        return text
